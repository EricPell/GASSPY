"""
    AUTHORS:  Loke Ohlin
    DATE: 13/04-2023
    PURPOSE:
        DatabasePopulator class:
            This class takes a skeleton database with all required models (generated by a DatabaseGenerator object) and used a ModelRunner class
            to run each model and save the resulting intensity and opacity
    USAGE:
        See test example in __name__ == "__main__"
"""


import os
import sys
import numpy as np
import time
from mpi4py import MPI
import h5py as hp
import traceback

from gasspy.io.gasspy_io import check_parameter_in_config, read_yaml
from gasspy.shared_utils.mpi_utils.mpi_print import mpi_print, mpi_all_print

mpi_comm = MPI.COMM_WORLD
mpi_rank = mpi_comm.rank
mpi_size = mpi_comm.Get_size()

class DatabasePopulator(object):
    def __init__(self, 
                 gasspy_config, 
                 model_runner,
                 populator_dump_time = None,
                 est_model_time = None,
                 max_walltime = None,
                 gasspy_modeldir = None,
                 database_name = None,
                 h5database = None,
                 ) -> None:


        if isinstance(gasspy_config, str):
            self.gasspy_config = read_yaml(gasspy_config)
        else:
            self.gasspy_config = gasspy_config

        ##
        #  Name and path of hdf5 database 
        ## 

        # Name of the database which we are using
        self.database_name = check_parameter_in_config(self.gasspy_config, "database_name", database_name, "gasspy_database.hdf5") 
        
        # Path to database directory
        self.gasspy_modeldir = check_parameter_in_config(self.gasspy_config, "gasspy_modeldir", gasspy_modeldir, "gasspy_modeldir") 
        if not self.gasspy_modeldir.endswith("/"):
            self.gasspy_modeldir = self.gasspy_modeldir + "/"
        
        # an h5database can be passed such that it can be active here and for other purposes
        try:
            self.load_database(h5database = h5database)
        except:
            mpi_all_print(traceback.format_exc())
            mpi_comm.Abort(1)  

        # Set dump timing information
        self.populator_dump_time = check_parameter_in_config(self.gasspy_config, "populator_dump_time", populator_dump_time, 1800) # Default 30 minutes
        self.est_model_time = check_parameter_in_config(self.gasspy_config, "est_model_time", est_model_time, 10) # Estimate 10 seconds per model
        self.max_walltime = check_parameter_in_config(self.gasspy_config, "max_walltime", max_walltime, 1e99) # infinte
        
        # set model_runner
        self.model_runner = model_runner

        # allocate buffer arrays
        self.allocate_local_buffers()

        self.local_n_complete = 0


        return

        
    def load_database(self, h5database = None):
        """
            Method to load database of models to populate
            input:
                h5file: h5database (optional, an active instance of an h5database)
        """
        if mpi_rank == 0: # For now only use single threaded hdf5. Should change in the future
            if h5database is None:
                if not os.path.exists(self.gasspy_modeldir + self.database_name):
                    sys.exit("ERROR: cannot find database %s"%self.gasspy_modeldir + self.database_name)
                self.h5database = hp.File(self.gasspy_modeldir + self.database_name, "r+")
            else:
                self.h5database = h5database

        
            # Load contained fields
            fields = self.h5database["database_fields"][:]
            self.database_fields = []
            for field in fields:
                self.database_fields.append(field.decode())
        else:
            self.database_fields = None
        
        # Distribute fields to all ranks
        self.database_fields = mpi_comm.bcast(self.database_fields, root = 0)

        return

    def check_database(self):
        if mpi_rank != 0:
            return
        # Load models
        self.unique_models = self.h5database["unique_models"][:,:]
        self.N_unique = self.unique_models.shape[0]

        # If we have populated this database before, check if we have added new models since 
        if "intensity" in self.h5database:
            if self.h5database["intensity"].shape[0] != self.N_unique:
                old_N_unique = self.h5database["intensity"].shape[0]
                for key in ["intensity", "opacity", "model_completed", "model_successful"]:
                    self.h5database[key].resize((self.N_unique), axis=0)
                    self.h5database[key][old_N_unique:] = 0
        
        # If we havent populated this dataset before, create room for model completion and success flags
        if not "model_completed" in self.h5database:
            self.h5database.create_dataset("model_completed" , shape = (self.unique_models.shape[0],), maxshape=(None,), dtype = int)
            self.h5database.create_dataset("model_successful", shape = (self.unique_models.shape[0],), maxshape=(None,), dtype = int)

    def save_models(self, intensity, opacity, model_successful, gasspy_ids):
        """
            Method to save a list of models
        """
        # Only main rank does this
        if mpi_rank != 0:
            return
        
        # Start by sorting since h5py is picky
        sorter = gasspy_ids.argsort()
        gasspy_ids = gasspy_ids[sorter]
        intensity  = intensity[sorter,:]
        opacity    = opacity[sorter,:]
        model_successful = model_successful[sorter]

        # If this is the first time we save, we must create the dataset (since we now know the shape)
        if not "intensity" in self.h5database:
            self.h5database.create_dataset("intensity", shape = (self.N_unique, intensity.shape[1]),maxshape=(None,intensity.shape[1]))
            self.h5database.create_dataset("opacity"  , shape = (self.N_unique, intensity.shape[1]),maxshape=(None,intensity.shape[1]))
            # Also save energy bin information here
            self.h5database["energy"] = self.model_runner.get_energy_bins()
            self.h5database["delta_energy"] = self.model_runner.get_delta_energy_bins()        
        # Save these models
        self.h5database["intensity"][gasspy_ids,:] = intensity
        self.h5database["opacity"][gasspy_ids,:] = opacity
        self.h5database["model_successful"][gasspy_ids] = model_successful
        self.h5database["model_completed"][gasspy_ids] = 1

    def distribute_models(self):
        """
            Method to distribute models to be run from the main rank to all ranks
        """
        self.check_database()
        if mpi_rank == 0:
            # Determine all unique models
            unfinished_models = np.where(self.h5database["model_completed"][:] == 0)[0]
            
            # How many should each rank have?
            N_unfinished = len(unfinished_models)
            N_per_rank = N_unfinished/mpi_size 
            # Distribute models and gasspy_ids to each rank
            for irank in range(1,mpi_size):
                istart = int(np.round((irank-1)*N_per_rank))
                iend = min(int(np.round((irank)*N_per_rank)),N_unfinished-1)
    
                gasspy_ids = unfinished_models[istart: iend]
                n_models_to_send = len(gasspy_ids)
                mpi_comm.send(n_models_to_send, dest = irank, tag = 0)
                if n_models_to_send == 0:
                    continue
                mpi_comm.send(gasspy_ids, dest = irank, tag = 1)
                models_to_send = self.unique_models[gasspy_ids,:]
                mpi_comm.send(models_to_send, dest = irank, tag = 2)
            
            # Take remaining models as local (minimum of one)
            istart = min(int(np.round((mpi_size-1)*N_per_rank)),N_unfinished-1)

            self.gasspy_ids    = unfinished_models[istart:]
            self.models_to_run = self.unique_models[self.gasspy_ids,:]

            mpi_print("Running %d new models"%N_unfinished)
        else:
            # Recieve models and gasspy_ids from rank 0
            n_models_to_recieve = mpi_comm.recv(source= 0, tag = 0)
            if n_models_to_recieve > 0:
                self.gasspy_ids = mpi_comm.recv(source = 0, tag = 1)
                self.models_to_run = mpi_comm.recv(source = 0, tag= 2)
            else :
                self.gasspy_ids = np.array([], dtype = int)
                self.models_to_run = np.array([], dtype = int)
    def gather_results(self):
        """
            Method to gather the results from the run models in the buffers
        """
        # Determine how many models were completed across all ranks
        n_complete_rank = np.zeros(mpi_size, dtype = int)
        n_complete_rank[:] = mpi_comm.allgather(self.local_n_complete)
        n_complete_cum = np.cumsum(n_complete_rank)
        n_complete_total = np.sum(n_complete_rank)
        
        if n_complete_total == 0:
            return
        if mpi_rank == 0:
            # Create arrays to store these models
            all_intensity = np.zeros((n_complete_total, self.buffer_intensity.shape[1]))
            all_opacity = np.zeros((n_complete_total, self.buffer_intensity.shape[1]))
            all_model_successful = np.zeros((n_complete_total), dtype = int)
            all_gasspy_ids = np.zeros((n_complete_total), dtype = int)

            # Set values for local completed models
            if self.local_n_complete > 0:
                all_intensity[:self.local_n_complete,:] = self.buffer_intensity[:self.local_n_complete,:]
                all_opacity[:self.local_n_complete,:] = self.buffer_opacity[:self.local_n_complete,:]
                all_model_successful[:self.local_n_complete] = self.buffer_model_successful[:self.local_n_complete]
                all_gasspy_ids[:self.local_n_complete] = self.buffer_gasspy_ids[:self.local_n_complete]

            # Loop over all ranks and gather completed models from other ranks
            for irank in range(1, mpi_size):
                if n_complete_rank[irank] == 0:
                    continue
                all_intensity[n_complete_cum[irank-1]:n_complete_cum[irank],:] = mpi_comm.recv(source = irank, tag = 4*irank + 1)
                all_opacity[n_complete_cum[irank-1]:n_complete_cum[irank],:] = mpi_comm.recv(source = irank, tag = 4*irank + 2)
                all_model_successful[n_complete_cum[irank-1]:n_complete_cum[irank]] = mpi_comm.recv(source = irank, tag = 4*irank + 3)
                all_gasspy_ids[n_complete_cum[irank-1]:n_complete_cum[irank]] = mpi_comm.recv(source = irank, tag = 4*irank + 4)
            
            # Save them
            mpi_print("\tdumping %d models"%n_complete_total)
            self.save_models(all_intensity, all_opacity, all_model_successful, all_gasspy_ids)

        
        else: # if not main rank
            if self.local_n_complete == 0:
                return
            mpi_comm.send(self.buffer_intensity[:self.local_n_complete,:], dest = 0, tag = 4*mpi_rank + 1)            
            mpi_comm.send(self.buffer_opacity[:self.local_n_complete,:], dest = 0, tag = 4*mpi_rank + 2)            
            mpi_comm.send(self.buffer_model_successful[:self.local_n_complete], dest = 0, tag = 4*mpi_rank + 3)            
            mpi_comm.send(self.buffer_gasspy_ids[:self.local_n_complete], dest = 0, tag = 4*mpi_rank + 4)

    def allocate_local_buffers(self):
        """
            Method to allocate the buffers
        """
        n_spectral_bins = len(self.model_runner.get_energy_bins())
        # How many do we expect?
        n_buffered_models = int(self.populator_dump_time/self.est_model_time) + 1
        self.buffer_intensity = np.zeros((n_buffered_models,n_spectral_bins), dtype = float)
        self.buffer_opacity = np.zeros((n_buffered_models,n_spectral_bins), dtype = float)
        self.buffer_model_successful = np.zeros(n_buffered_models, dtype = int)
        self.buffer_gasspy_ids = np.zeros(n_buffered_models, dtype = int)
        self.local_n_complete = 0
        return
    
    def reset_local_buffers(self):  
        """
            Method to reset the buffers
        """
        # if they havent been allocated, do nothing
        self.buffer_intensity[:,:] = 0
        self.buffer_opacity[:,:] = 0          
        self.buffer_model_successful[:] = 0
        self.buffer_gasspy_ids[:] = 0
        self.local_n_complete = 0
        return

    def __run_models__(self):
        """
            Main call to run all required models
        """
        # Distribute models from main rank
        self.distribute_models()

        # Set timers
        start_runtime = time.time()
        time_since_last_dump = time.time()
        self.local_n_complete = 0

        # Loop over all models
        all_ranks_complete = np.array([mpi_comm.allgather(0)])
        sys.stdout.flush()
        for imodel in range(len(self.models_to_run)):
            # Grab current model
            gasspy_id = self.gasspy_ids[imodel]
            model = self.models_to_run[imodel,:]

            # Create dictionary of fields needed for the model_runner
            model_dict = {}
            for field in self.model_runner.required_fields:
                if field not in self.database_fields:
                    mpi_print("ERROR: could not find field %s required by model_runner in database"%field)
                    mpi_print("Fields required by model_runner :")
                    mpi_print(self.model_runner.required_fields)
                    mpi_print("Fields in database :")
                    mpi_print(self.database_fields)                   
                    sys.exit(0)

                ifield = self.database_fields.index(field)
                model_dict[field] = model[ifield]
            
            # Send model to model_runner
            self.model_runner.run_model(model_dict, "gasspy_%d"%gasspy_id)

            # set success state and gasspy id
            self.buffer_model_successful[self.local_n_complete] = self.model_runner.model_successful()
            self.buffer_gasspy_ids[self.local_n_complete] = gasspy_id

            if self.model_runner.model_successful():   
                # Get intensity and opacity off model
                self.buffer_intensity[self.local_n_complete,:] = self.model_runner.get_intensity()
                self.buffer_opacity[self.local_n_complete,:] = self.model_runner.get_opacity()
            

            
            # advance number of completed models
            self.local_n_complete += 1

            # Check if we need to dump or exit the loop
            current_time = time.time()

            if current_time - start_runtime >= self.max_walltime or current_time - time_since_last_dump > self.populator_dump_time or imodel == len(self.models_to_run)-1:
                self.gather_results()
                self.reset_local_buffers() 
                self.local_n_complete = 0
                if imodel == len(self.models_to_run) - 1 or current_time - start_runtime >= self.max_walltime :
                    all_ranks_complete[:] = mpi_comm.allgather(1)
                else:
                    all_ranks_complete[:] = mpi_comm.allgather(0)


                time_since_last_dump = time.time()
                
            
            self.model_runner.delete_files()
            if current_time - start_runtime >= self.max_walltime:
                break
        # Continue "gathering" untill every rank has completed all their models
        while np.sum(all_ranks_complete == 0) > 0:
            self.gather_results()
            self.local_n_complete = 0
            all_ranks_complete[:] = mpi_comm.allgather(1)

        mpi_print("")  
    
    def run_models(self):
        """
            Main call to run all required models
        """
        try:
            self.__run_models__()
        except:
            mpi_all_print(traceback.format_exc())
            mpi_comm.Abort(1)            

    def __finalize__(self, close_hdf5 = True):
        """
            Method to safely finalize 
        """
        # only needed for rank 0
        if mpi_rank != 0:
            return

        model_completed = self.h5database["model_completed"][:]
        model_successful = self.h5database["model_successful"][:]
        print("Database contains %d models, %d have been populated with spectra, %d still need to be run"%(len(model_completed), np.sum(model_completed==1), np.sum(model_completed==0)))
        
        N_failed = np.sum(model_successful[model_completed==1]==0)
        if N_failed > 0:
            print("%d models failed. Please figure out why and if you care"%np.sum(model_successful[model_completed==1]==0))
        # Close the database
        if close_hdf5:
            self.h5database.close()

    def finalize(self, close_hdf5 = True):
        try: 
            self.__finalize__(close_hdf5=close_hdf5)
        except:
            mpi_all_print(traceback.format_exc())
            mpi_comm.Abort(1)

####################################################################################
# TESTING
####################################################################################
"""
    testunit:
    1) Generate multiple simulation_readers with fields
    2) Add one
    3) Add the other
    4) check that it all makes sense
"""
if __name__ == "__main__":

    class ModelRunner:
        """ 
            Dummy ModelRunner class
        """
        def __init__(self):
            self.required_fields = ["var1", "var2"]
            return

        def run_model(self, model_dict, model_name):
            value = int(model_name[len("gasspy_"):])
            self.intensity = np.full(100, value) # set to the gasspy_id for easy testing
            self.opacity = np.full(100, value)
            time.sleep(1) # pretend to take 1 second per model

        def get_intensity(self):
            return self.intensity
        
        def get_opacity(self):
            return self.opacity
        
        def model_successful(self):
            return 1
        
        def get_energy_bins(self):
            return np.arange(100)
        def get_delta_energy_bins(self):
            return np.full(100,1)
        def delete_files(self):
            return
    # Simple gasspy config with needed parameters
    gasspy_config = {
        "database_name" : "test_database.hdf5",
        "gasspy_modeldir" : "./test_database/",
        "database_fields" :[ 
              "var1",
              "var2"
        ],
        "populator_dump_time" : 7, # approximatly 7 models per dump 
        "est_model_time" : 0.5 # lowball a bit
    }

    model_runner = ModelRunner()

    # Create fake data of 10 models
    N_models = 10
    if mpi_rank == 0:
        import shutil
        if os.path.exists("test_database"):
            shutil.rmtree("test_database")

        os.makedirs("test_database")
    
        # Create a fake test_database
        h5database = hp.File("test_database/test_database.hdf5", "w")
        h5database.create_dataset("unique_models", shape = (N_models,2), maxshape = (None,2))

        models = np.array([np.arange(N_models),np.arange(N_models)]).T
        h5database["unique_models"][:,:] = models 
        h5database["database_fields"] = ["var1" , "var2"]
        h5database.close()

    # Start by running all of them
    mpi_print("All new")
    database_populator = DatabasePopulator(gasspy_config, model_runner)
    database_populator.run_models()
    database_populator.finalize()
    
    del database_populator
    N_new_models = mpi_size * 10 # 10 new per rank
    N_old = N_models
    N_models = N_models + N_new_models
    max_walltime = 5 # limit runtime
    if mpi_rank == 0:
        # Test adding new models and also running out of walltime
        h5database = hp.File("test_database/test_database.hdf5", "r+")



        new_models = np.array([np.arange(N_models),np.arange(N_models)]).T
        h5database["unique_models"].resize((N_models), axis = 0)
        h5database["unique_models"][:,:] = new_models
    else:
        h5database = None

    database_populator = DatabasePopulator(gasspy_config, model_runner, max_walltime=max_walltime, h5database=h5database)
    database_populator.run_models()
    database_populator.finalize(close_hdf5=False)

    if mpi_rank == 0:
        n_not_complete = np.sum(h5database["model_completed"][:] == 0)
        for irank in range(1, mpi_size):
            mpi_comm.send(n_not_complete, dest = irank, tag = irank) 
    else:
        n_not_complete = mpi_comm.recv(source = 0, tag = mpi_rank)
    while n_not_complete> 0:
        database_populator = DatabasePopulator(gasspy_config, model_runner, max_walltime=max_walltime, h5database=h5database)
        database_populator.run_models()
        database_populator.finalize(close_hdf5=False)
        if mpi_rank == 0:
            n_not_complete = np.sum(h5database["model_completed"][:] == 0)
            for irank in range(1, mpi_size):
                mpi_comm.send(n_not_complete, dest = irank, tag = irank) 
        else:
            n_not_complete = mpi_comm.recv(source = 0, tag = mpi_rank)

    if mpi_rank == 0:
        # Make sure all models are completed and successful, and that their intensities and opacities are correctly saved
        intensity = h5database["intensity"][:,:]
        opacity = h5database["opacity"][:,:]
        model_completed = h5database["model_completed"][:]
        model_successful = h5database["model_successful"][:]    

        if np.sum(model_completed == 0) > 0:
            print("Error: not all models completed") 
        if np.sum(model_successful == 0) > 0:
            print("Error: not all models successful")

        ids = np.arange(len(model_completed))
        if np.sum(intensity[:,0]!= ids):
            print("Error: intensities do not match their ids") 
        if np.sum(opacity[:,0]!= ids):
            print("Error: opacity do not match their ids") 

        shutil.rmtree("test_database")
